#!/usr/bin/env node

/**
 * GitHub Issues to Maintenance Sync Script
 * Fetches maintenance issues from GitHub API and generates maintenances.ts
 */

const fs = require('fs')
const path = require('path')
const { execSync } = require('child_process')

class GitHubMaintenanceSync {
  constructor(options = {}) {
    this.owner = options.owner || process.env.GITHUB_REPOSITORY?.split('/')[0]
    this.repo = options.repo || process.env.GITHUB_REPOSITORY?.split('/')[1]
    this.token = options.token || process.env.GITHUB_TOKEN
    this.apiUrl = options.apiUrl || 'https://api.github.com'
  }

  async fetchMaintenanceIssues() {
    if (!this.owner || !this.repo) {
      throw new Error('Missing required GitHub configuration: owner or repo')
    }

    if (!this.token) {
      throw new Error('Missing required GitHub token')
    }

    const url = `${this.apiUrl}/repos/${this.owner}/${this.repo}/issues?labels=maintenance&state=open&per_page=100`

    console.log(`üîç Fetching maintenance issues from GitHub...`)
    console.log(`   Repository: ${this.owner}/${this.repo}`)

    try {
      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${this.token}`,
          Accept: 'application/vnd.github.v3+json',
          'User-Agent': 'UptimeFlare-Maintenance-Sync/1.0',
        },
      })

      if (!response.ok) {
        const errorText = await response.text()
        throw new Error(
          `GitHub API error: ${response.status} ${response.statusText} - ${errorText}`
        )
      }

      const issues = await response.json()
      console.log(`   Found ${issues.length} open maintenance issues`)

      return issues
    } catch (error) {
      console.error('‚ùå Error fetching issues from GitHub:', error.message)
      throw error
    }
  }

  parseMaintenanceFromIssue(issue) {
    try {
      // Issue title becomes maintenance title
      const title = issue.title || 'Scheduled Maintenance'

      // Issue body becomes maintenance body (without keywords)
      let body = issue.body || 'Maintenance in progress'

      // Extract keywords from body
      const startMatch = body.match(/start:\s*([^\s\n]+)/i)
      const endMatch = body.match(/end:\s*([^\s\n]+)/i)
      const colorMatch = body.match(/color:\s*([^\s\n]+)/i)

      // Remove keywords from body for cleaner display
      body = body
        .replace(/start:\s*[^\s\n]+/gi, '')
        .replace(/end:\s*[^\s\n]+/gi, '')
        .replace(/color:\s*[^\s\n]+/gi, '')
        .replace(/\n\s*\n/g, '\n')
        .trim()

      // Extract monitor IDs from labels (excluding 'maintenance' label)
      const monitorLabels = (issue.labels || [])
        .map((label) => (typeof label === 'string' ? label : label.name))
        .filter((label) => label !== 'maintenance')

      // Create maintenance config
      const maintenance = {
        title: title,
        body: body,
        _issueNumber: issue.number,
        _issueState: issue.state,
        _issueUrl: issue.html_url,
      }

      // Add start time if specified
      if (startMatch) {
        maintenance.start = startMatch[1]
      }

      // Add end time if specified
      if (endMatch) {
        maintenance.end = endMatch[1]
      }

      // Add color if specified (support both hex and color names)
      if (colorMatch) {
        let color = colorMatch[1]
        if (color) maintenance.color = color
      }

      // Add monitors if specified (empty array if no labels)
      if (monitorLabels.length > 0) {
        maintenance.monitors = monitorLabels
      }

      console.log(`   ‚úÖ Parsed issue #${issue.number}: ${title}`)
      return maintenance
    } catch (error) {
      console.error(`‚ùå Error processing issue #${issue.number}:`, error.message)
      return null
    }
  }

  processIssues(issues) {
    console.log(`\nüìä Processing ${issues.length} maintenance issues...`)

    const maintenances = []

    for (const issue of issues) {
      const maintenance = this.parseMaintenanceFromIssue(issue)
      if (maintenance) {
        maintenances.push(maintenance)
      }
    }

    // Sort by start time if available, otherwise by issue number
    maintenances.sort((a, b) => {
      if (a.start && b.start) {
        return new Date(a.start) - new Date(b.start)
      }
      return a._issueNumber - b._issueNumber
    })

    console.log(`   Generated ${maintenances.length} valid maintenance entries`)
    return maintenances
  }

  generateMaintenancesFile(maintenances) {
    const header = `// This file is auto-generated by GitHub Actions
// DO NOT EDIT MANUALLY - Changes will be overwritten
// Generated from GitHub Issues with label 'maintenance'
// Last updated: ${new Date().toISOString()}

import { MaintenanceConfig } from './types/config'

export const maintenances: MaintenanceConfig[] = [`

    const footer = `]`

    let maintenanceEntries = ''

    for (const maintenance of maintenances) {
      const monitors =
        maintenance.monitors && maintenance.monitors.length > 0
          ? `\n    monitors: ${JSON.stringify(maintenance.monitors)},`
          : ''

      const start = maintenance.start ? `\n    start: '${maintenance.start}',` : ''

      const end = maintenance.end ? `\n    end: '${maintenance.end}',` : ''

      const color = maintenance.color ? `\n    color: '${maintenance.color}',` : ''

      maintenanceEntries += `
  {
    title: '${maintenance.title.replace(/'/g, "\\'")}',
    body: \`${maintenance.body
      .replace(/`/g, '\\`')
      .replace(/\$/g, '\\$')}\`,${start}${end}${color}${monitors}
  },`
    }

    const fileContent = header + maintenanceEntries + '\n' + footer + '\n'
    return fileContent
  }

  writeMaintenancesFile(content, outputPath = null) {
    if (!outputPath) {
      outputPath = path.join(__dirname, '..', 'maintenances.ts')
    }

    fs.writeFileSync(outputPath, content, 'utf8')
    console.log(`\n‚úÖ Generated maintenances.ts`)
    console.log(`   File location: ${outputPath}`)

    return outputPath
  }

  displayMaintenancesSummary(maintenances) {
    if (maintenances.length === 0) {
      console.log('\nüìã No active maintenances found')
      return
    }

    console.log('\nüìã Generated maintenances:')
    console.log('‚îÄ'.repeat(60))

    maintenances.forEach((m, i) => {
      const monitors = m.monitors && m.monitors.length > 0 ? m.monitors.join(', ') : 'All monitors'

      console.log(`${i + 1}. ${m.title}`)
      console.log(`   Start: ${m.start || 'Not specified'}`)
      console.log(`   End: ${m.end || 'Ongoing'}`)
      console.log(`   Color: ${m.color || 'Default'}`)
      console.log(`   Monitors: ${monitors}`)
      console.log(`   Issue: #${m._issueNumber} (${m._issueState})`)
      console.log(`   URL: ${m._issueUrl}`)
      console.log('')
    })
  }

  async generateIssueComment(maintenance, issueNumber) {
    const monitors =
      maintenance.monitors && maintenance.monitors.length > 0
        ? maintenance.monitors.join(', ')
        : 'All monitors'

    const schedule = maintenance.start
      ? `\n- **Start:** ${maintenance.start}${
          maintenance.end ? `\n- **End:** ${maintenance.end}` : '\n- **End:** Ongoing'
        }`
      : '\n- **Schedule:** No specific timing'

    const color = maintenance.color ? `\n- **Color:** ${maintenance.color}` : ''

    const message = `‚úÖ **Maintenance Configuration Updated**

**Generated Configuration:**
- **Title:** ${maintenance.title}
- **Affected Monitors:** ${monitors}${schedule}${color}

The maintenance has been automatically added to the system and will appear on the status page according to the specified schedule.

**Keywords detected in description:**
${
  maintenance.start
    ? '- ‚úÖ `start:` - Start time configured'
    : '- ‚ùå `start:` - No start time specified'
}
${
  maintenance.end
    ? '- ‚úÖ `end:` - End time configured'
    : '- ‚ùå `end:` - No end time (ongoing maintenance)'
}
${
  maintenance.color
    ? '- ‚úÖ `color:` - Custom color configured'
    : '- ‚ùå `color:` - Using default color'
}

*This comment was automatically generated by the maintenance sync workflow.*`

    return message
  }

  async postIssueComment(issueNumber, message) {
    if (!this.owner || !this.repo || !this.token) {
      console.log(`‚ö†Ô∏è  Cannot post comment: missing GitHub configuration`)
      return false
    }

    const url = `${this.apiUrl}/repos/${this.owner}/${this.repo}/issues/${issueNumber}/comments`

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.token}`,
          Accept: 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
          'User-Agent': 'UptimeFlare-Maintenance-Sync/1.0',
        },
        body: JSON.stringify({ body: message }),
      })

      if (!response.ok) {
        const errorText = await response.text()
        console.log(
          `‚ö†Ô∏è  Failed to post comment to issue #${issueNumber}: ${response.status} ${errorText}`
        )
        return false
      }

      console.log(`‚úÖ Posted confirmation comment to issue #${issueNumber}`)
      return true
    } catch (error) {
      console.log(`‚ö†Ô∏è  Error posting comment to issue #${issueNumber}:`, error.message)
      return false
    }
  }

  checkForChanges(outputPath) {
    try {
      // Check if there are git changes
      execSync('git diff --quiet HEAD -- maintenances.ts', {
        stdio: 'pipe',
        cwd: path.dirname(outputPath),
      })
      return false // No changes
    } catch (error) {
      // Could be changes detected or git not available
      if (error.status === 1) {
        return true // Changes detected
      }
      console.log('‚ö†Ô∏è  Unable to check git status, assuming changes exist')
      return true
    }
  }

  commitChanges(outputPath, issueNumber = null) {
    try {
      const repoDir = path.dirname(outputPath)

      execSync('git add maintenances.ts', { cwd: repoDir })

      const commitMessage = issueNumber
        ? `Auto-update maintenances from issue #${issueNumber}\n\nUpdated maintenance configurations based on GitHub Issues.\nGenerated by: maintenance sync workflow`
        : `Auto-update maintenances from GitHub Issues\n\nUpdated maintenance configurations based on GitHub Issues.\nGenerated by: maintenance sync workflow`

      execSync(`git commit -m "${commitMessage}"`, { cwd: repoDir })

      console.log('‚úÖ Changes committed to git')
      return true
    } catch (error) {
      console.log('‚ö†Ô∏è  Git operations skipped (not in git repository or no changes)')
      return false
    }
  }

  async sync(options = {}) {
    const {
      outputPath = null,
      postComments = false,
      triggerIssueNumber = null,
      commitChanges = false,
    } = options

    try {
      console.log('üîÑ Starting GitHub Issues maintenance sync...\n')

      // Fetch issues from GitHub
      const issues = await this.fetchMaintenanceIssues()

      // Process issues into maintenance configs
      const maintenances = this.processIssues(issues)

      // Generate TypeScript file content
      const fileContent = this.generateMaintenancesFile(maintenances)

      // Write to file
      const finalOutputPath = this.writeMaintenancesFile(fileContent, outputPath)

      // Display summary
      this.displayMaintenancesSummary(maintenances)

      // Post comment to trigger issue if requested
      if (postComments && triggerIssueNumber) {
        const triggerMaintenance = maintenances.find((m) => m._issueNumber === triggerIssueNumber)
        if (triggerMaintenance) {
          const comment = await this.generateIssueComment(triggerMaintenance, triggerIssueNumber)
          await this.postIssueComment(triggerIssueNumber, comment)
        }
      }

      // Commit changes if requested
      if (commitChanges) {
        const hasChanges = this.checkForChanges(finalOutputPath)
        if (hasChanges) {
          this.commitChanges(finalOutputPath, triggerIssueNumber)
        } else {
          console.log('‚ÑπÔ∏è  No changes detected, skipping commit')
        }
      }

      console.log('\nüéâ Maintenance sync completed successfully!')

      return {
        success: true,
        maintenances: maintenances,
        outputPath: finalOutputPath,
      }
    } catch (error) {
      console.error('\n‚ùå Maintenance sync failed:', error.message)

      return {
        success: false,
        error: error.message,
      }
    }
  }
}

// CLI interface
async function main() {
  const args = process.argv.slice(2)

  const options = {
    postComments: args.includes('--post-comments'),
    commitChanges: args.includes('--commit'),
    triggerIssueNumber: null,
  }

  // Parse trigger issue number
  const triggerArg = args.find((arg) => arg.startsWith('--trigger-issue='))
  if (triggerArg) {
    options.triggerIssueNumber = parseInt(triggerArg.split('=')[1])
  }

  const sync = new GitHubMaintenanceSync()
  const result = await sync.sync(options)

  process.exit(result.success ? 0 : 1)
}

// Run if called directly
if (require.main === module) {
  main().catch((error) => {
    console.error('‚ùå Fatal error:', error.message)
    process.exit(1)
  })
}

module.exports = { GitHubMaintenanceSync }
